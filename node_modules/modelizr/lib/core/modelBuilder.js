'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _uniqBy2 = require('lodash/uniqBy');

var _uniqBy3 = _interopRequireDefault(_uniqBy2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _filters = require('../tools/filters');

var _types = require('../types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Construct a functional representation of a model. This method contains
 * no field information but rather config that is used when generating
 * a query.
 *
 * The resulting ModelFunction is a model-builder function, meaning the result
 * of calling it is a new ModelFunction that contains the changes to the
 * original.
 */
var createModel = function createModel(modelName) {

	/* The ModelFunction that is returned. This stores information for
  * query generation such as the FieldName, ModelName of the data it
  * represents, query parameters and all children models it should
  * generate.
  * */
	var model = function model(fieldName, modelParams) {
		for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			children[_key - 2] = arguments[_key];
		}

		var _normalizeFunctionPar = (0, _filters.normalizeFunctionParameters)(fieldName, modelParams, children),
		    name = _normalizeFunctionPar.name,
		    params = _normalizeFunctionPar.params,
		    models = _normalizeFunctionPar.models;

		var newModel = createModel(modelName);
		newModel.fieldName = name || model.fieldName;
		newModel.params = _extends({}, model.params, params || {});
		newModel.children = [].concat(_toConsumableArray(model.children), _toConsumableArray(models || []));

		newModel.children = (0, _uniqBy3.default)(newModel.children, function (child) {
			return child.fieldName;
		});

		return newModel;
	};

	/* We want to store the model name and field name
  * separately as the field name can change on a per
  * query basis, while the model name must always
  * remain consistent.
  * */
	model.modelName = modelName;
	model.fieldName = modelName;

	model.params = {};
	model.children = [];
	model.filters = {};

	/* Modifiers that allows for white-listing and
  * black-listing model fields on a per-query basis.
  * */
	model.only = function (fields) {
		var newModel = model();
		newModel.filters.only = [].concat(_toConsumableArray(model.filters.only || []), _toConsumableArray(fields));
		return newModel;
	};

	model.without = function (fields) {
		var newModel = model();
		newModel.filters.without = [].concat(_toConsumableArray(model.filters.without || []), _toConsumableArray(fields));
		return newModel;
	};

	model.empty = function () {
		var newModel = model();
		newModel.filters.empty = true;
		return newModel;
	};

	return model;
};

exports.default = createModel;