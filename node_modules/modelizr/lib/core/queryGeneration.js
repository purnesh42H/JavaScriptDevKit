'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _pickBy2 = require('lodash/pickBy');

var _pickBy3 = _interopRequireDefault(_pickBy2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _times2 = require('lodash/times');

var _times3 = _interopRequireDefault(_times2);

var _join2 = require('lodash/join');

var _join3 = _interopRequireDefault(_join2);

var _types = require('../types');

var _filters = require('../tools/filters');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Utility method that generates a certain amount of spaces
 * in a string.
 */
var SPACES = 2;
var createIndent = function createIndent(spaces) {
	return (0, _join3.default)((0, _times3.default)(spaces * SPACES + 1, function () {
		return "";
	}), " ");
};

/* Construct a valid GraphQL parameter string from an object */
var buildParameters = function buildParameters(params) {
	if (!params || (0, _isEmpty3.default)(params)) return "";
	return '(' + (0, _map3.default)((0, _pickBy3.default)(params, function (param) {
		return param || param === false;
	}), function (param, key) {
		return key + ': ' + JSON.stringify(param).replace(/"([^(")"]+)":/g, "$1:");
	}) + ')';
};

/**
 * Generate a GraphQL query from a collection of modelizr models.
 */

exports.default = function (_ref) {
	var clientState = _ref.clientState,
	    queryModels = _ref.queryModels,
	    queryType = _ref.queryType,
	    queryName = _ref.queryName,
	    queryParams = _ref.queryParams;
	var models = clientState.models;

	/* This compiles a FieldMap from a a collection of models. It is much
  * easier to generate a query from a normalized description of fields.
  * */

	var createMap = function createMap(queryModels) {
		var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
		return (0, _map3.default)(queryModels, function (modelFunction) {
			var modelData = models[modelFunction.modelName];

			/* Utility that strips modifier rejected fields. */
			var filter = function filter(fields) {
				return (0, _pickBy3.default)(fields, function (field, fieldName) {
					var _modelFunction$filter = modelFunction.filters,
					    only = _modelFunction$filter.only,
					    without = _modelFunction$filter.without,
					    empty = _modelFunction$filter.empty;

					if (only) return (0, _find3.default)(only, function (field) {
						return field == fieldName;
					});
					if (without) return !(0, _find3.default)(without, function (field) {
						return field == fieldName;
					});
					if (empty) return false;
					return true;
				});
			};

			/* Filter out fields that have been rejected via modifiers,
    * strip any model relationships from the fields and recursively
    * generate a FieldMap.
    * */
			var pruneFields = function pruneFields(fields) {
				return (0, _map3.default)(filter((0, _filters.stripRelationships)(fields)), function (field, fieldName) {

					/* We check for an alias property on the field type.
      * If one is found, use it instead of the fieldName
      * */
					if (field.alias) fieldName = fieldName + ': ' + field.alias;

					var type = field.type;
					if (Array.isArray(type)) type = type[0];
					if (type === Object) {
						return {
							name: fieldName,
							fields: pruneFields(field.properties || {})
						};
					}

					return fieldName;
				});
			};

			return {
				name: '' + (prefix ? "... on " : "") + modelFunction.fieldName,
				params: modelFunction.params,
				fields: [].concat(_toConsumableArray(pruneFields(modelData.fields)), _toConsumableArray(createMap(modelFunction.children, modelData._unionDataType)))
			};
		});
	};

	var fieldMaps = createMap(queryModels);

	/* Generate an indented and multi-lined GraphQL query string
  * from our FieldMap. The type and name of the generated
  * query will be determined based on the queryType and queryName
  * parameters.
  * */
	var generateFields = function generateFields(FieldMap) {
		var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
		var name = FieldMap.name,
		    fields = FieldMap.fields,
		    params = FieldMap.params;

		var length = !!fields.length;

		return '\n' + createIndent(indent - 1) + name + buildParameters(params) + ' ' + (length ? "{" : "") + (0, _map3.default)(fields, function (field) {
			return typeof field === 'string' ? '\n' + createIndent(indent) + field : '' + generateFields(field, indent + 1);
		}) + '\n' + createIndent(indent - 1) + (length ? "}" : "");
	};

	return queryType + ' ' + (queryName || 'modelizr_' + queryType) + buildParameters(queryParams) + ' {' + (0, _map3.default)(fieldMaps, function (fieldMap) {
		return generateFields(fieldMap);
	}) + '\n}';
};