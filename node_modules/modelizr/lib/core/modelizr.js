'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _pickBy2 = require('lodash/pickBy');

var _pickBy3 = _interopRequireDefault(_pickBy2);

var _mapKeys2 = require('lodash/mapKeys');

var _mapKeys3 = _interopRequireDefault(_mapKeys2);

var _mapValues2 = require('lodash/mapValues');

var _mapValues3 = _interopRequireDefault(_mapValues2);

var _filter2 = require('lodash/filter');

var _filter3 = _interopRequireDefault(_filter2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _types = require('../types');

var _normalizr = require('normalizr');

var _filters = require('../tools/filters');

var _requestBuilder = require('./requestBuilder');

var _requestBuilder2 = _interopRequireDefault(_requestBuilder);

var _fetch = require('../tools/fetch');

var _modelBuilder = require('./modelBuilder');

var _modelBuilder2 = _interopRequireDefault(_modelBuilder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Modelizr = function () {
	function Modelizr(InitialClientState) {
		var _this = this;

		_classCallCheck(this, Modelizr);

		this.models = {};

		this.query = function () {
			return (0, _requestBuilder2.default)(_this.clientState, "query").apply(undefined, arguments);
		};

		this.mutate = function () {
			return (0, _requestBuilder2.default)(_this.clientState, "mutation").apply(undefined, arguments);
		};

		this.fetch = function () {
			return (0, _requestBuilder2.default)(_this.clientState, "fetch").apply(undefined, arguments);
		};

		if (!InitialClientState) throw new Error("Modelizr expects a Client State as its first parameter");

		this.clientState = InitialClientState;
		this.clientState.models = (0, _filters.normalizeModelData)(this.clientState.models);

		/* order is important, all model schemas must exist before
   * union schemas are created
   * */
		this.generateModelFunctions();
		this.buildUnionSchemas();
		this.defineModelRelationships();

		var defaultConfig = {
			mock: false,
			debug: false,
			api: _fetch.FETCH_API,
			throwOnErrors: true
		};

		this.clientState.config = _extends({}, defaultConfig, InitialClientState.config || {});
		if (!this.clientState.config.endpoint) throw new Error("Please provide a base endpoint to make queries to");
	}

	/* Create ModelFunctions from the given model Data.
  *
  * If the DataType is a model (and not a union) then build
  * its normalizr schema. We do not create schemas' for unions until
  * after _all_ model schemas are present.
  * */


	_createClass(Modelizr, [{
		key: 'generateModelFunctions',
		value: function generateModelFunctions() {
			var _this2 = this;

			var models = this.clientState.models;


			(0, _forEach3.default)(models, function (data, name) {
				var ModelData = _extends({}, data);

				if (!ModelData.normalizeAs) ModelData.normalizeAs = name;
				if (!ModelData.primaryKey) ModelData.primaryKey = "id";

				if (!ModelData._unionDataType) ModelData.normalizrSchema = new _normalizr.Schema(ModelData.normalizeAs, _extends({
					idAttribute: ModelData.primaryKey
				}, ModelData.normalizrOptions || {}));

				_this2.clientState.models[name] = ModelData;
				_this2.models[name] = (0, _modelBuilder2.default)(name);
			});
		}

		/* Build all normalizr schemas for union DataTypes. A check
   * to make sure the union is nor referencing imaginary models
   * is performed.
   * */

	}, {
		key: 'buildUnionSchemas',
		value: function buildUnionSchemas() {
			var models = this.clientState.models;


			(0, _forEach3.default)(models, function (modelData, modelName) {
				if (modelData._unionDataType) {

					/* filter out all non-existing models and warn about them */
					var existingModels = (0, _filter3.default)(modelData.models, function (model) {
						if (models[model]) return true;

						// eslint-disable-next-line no-console
						console.warn('Model "' + model + '" on union ' + modelName + ' points to an unknown model');
					});

					/* create a normalizr union */
					modelData.normalizrSchema = (0, _normalizr.unionOf)((0, _mapValues3.default)((0, _mapKeys3.default)(existingModels, function (model) {
						return model;
					}), function (model) {
						return models[model].normalizrSchema;
					}), { schemaAttribute: modelData.schemaAttribute });
				}
			});
		}

		/* Recursively populate relationship information of each models
   * normalizr schema
   * */

	}, {
		key: 'defineModelRelationships',
		value: function defineModelRelationships() {
			var models = this.clientState.models;


			/* Utility that flattens a field wrapped in an array */
			var unWrapArray = function unWrapArray(field) {
				return Array.isArray(field.type) ? { isArray: true, type: field.type[0] } : { isArray: false, type: field.type };
			};

			(0, _forEach3.default)(models, function (modelData, modelName) {
				if (!modelData._unionDataType) {

					/* Filter out any model references that do not exist in our data set */
					var modelFields = (0, _pickBy3.default)(modelData.fields, function (field, fieldName) {
						var _unWrapArray = unWrapArray(field),
						    isArray = _unWrapArray.isArray,
						    type = _unWrapArray.type;

						if (typeof type === 'string') {
							if (models[type]) return true;

							// eslint-disable-next-line no-console
							console.warn('Field { ' + fieldName + ': ' + (isArray ? "[" : "") + '"' + type + '"' + (isArray ? "]" : "") + ' } on \'' + modelName + '\' points to an unknown model');
						}
					});

					/* Recursively define all model relationships on
      * Model normalizr schemas
      * */
					modelData.normalizrSchema.define((0, _mapValues3.default)(modelFields, function (field) {
						var _unWrapArray2 = unWrapArray(field),
						    isArray = _unWrapArray2.isArray,
						    type = _unWrapArray2.type;

						var childModel = models[type];

						if (isArray) return (0, _normalizr.arrayOf)(childModel.normalizrSchema);
						return childModel.normalizrSchema;
					}));
				}
			});
		}
	}]);

	return Modelizr;
}();

exports.default = Modelizr;