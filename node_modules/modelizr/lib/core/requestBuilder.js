'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _filters = require('../tools/filters');

var _logger = require('../tools/logger');

var _queryGeneration = require('../core/queryGeneration');

var _queryGeneration2 = _interopRequireDefault(_queryGeneration);

var _normalization = require('../data/normalization');

var _normalization2 = _interopRequireDefault(_normalization);

var _mocks = require('../data/mocks');

var _mocks2 = _interopRequireDefault(_mocks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (clientState, queryType) {
	return function (queryName, queryParams) {
		for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			children[_key - 2] = arguments[_key];
		}

		var _normalizeFunctionPar = (0, _filters.normalizeFunctionParameters)(queryName, queryParams, children),
		    name = _normalizeFunctionPar.name,
		    params = _normalizeFunctionPar.params,
		    models = _normalizeFunctionPar.models;

		/* If debugging is enabled, create a logger instance, else
   * create a no-op debugger
   * */


		var logger = clientState.config.debug ? (0, _logger.createLogger)('[' + queryType + ': ' + (0, _map3.default)(models, function (model) {
			return model.FieldName;
		})) : {
			add: function add() {},
			print: function print() {}
		};

		/* generate the query and add it to the request body. If the
   * requestType is 'fetch', do not mutate the body
   * */
		var query = (0, _queryGeneration2.default)({ clientState: clientState, queryModels: models, queryType: queryType, queryName: name, queryParams: params });
		var config = _extends({}, clientState.config, {
			body: queryType == 'fetch' ? {} : { query: query }
		});

		/* Add the generated query to the debugging instance */
		if (queryType != 'fetch') logger.add("Query", query);

		/* A utility method that, when given a response - calls our internal
   * Normalize method with both the given response and the model tree.
   * */
		var _normalize = function _normalize(data) {
			return (0, _normalization2.default)({
				data: data,
				modelFunctions: models,
				clientState: clientState
			});
		};

		/* A utility method that calls the configured api and
   * adds the response to the debugger instance.
   * */
		var MAKE_REQUEST = function MAKE_REQUEST() {
			return (config.mock ? (0, _mocks2.default)(_extends({}, clientState, { config: config }), models) : config.api(config)).then(function (res) {
				logger.add("Server Response", res.server_response || {});
				logger.add("GraphQL response", {
					data: res.data,
					errors: res.errors
				});

				return res;
			}).catch(function (e) {
				logger.add("error", e);
				logger.print();
				throw e;
			});
		};

		/* Our request object that the user has access to. This object
   * contains all modifier methods as well the request catalysts,
   * .normalize() and .then()
   * */
		var REQUEST = {
			api: function api(_api) {
				if (_api) config.api = _api;
				return REQUEST;
			},
			endpoint: function endpoint(value) {
				if (value) config.endpoint = value;
				return REQUEST;
			},
			headers: function headers(_headers) {
				config.headers = _extends({}, config.headers, _headers);
				return REQUEST;
			},
			method: function method(value) {
				config.method = value || "POST";
				return REQUEST;
			},
			mock: function mock(value) {
				config.mock = value === undefined ? true : value;
				return REQUEST;
			},
			debug: function debug(value) {
				config.debug = value === undefined ? true : value;
				return REQUEST;
			},
			body: function body(_body) {
				if (_body) config.body = _body;
				return REQUEST;
			},
			throwOnErrors: function throwOnErrors(value) {
				config.throwOnErrors = value === undefined ? true : value;
				return REQUEST;
			},

			/* give the generated query to the provided callback and return the REQUEST object */
			generate: function generate(cb) {
				if (typeof cb !== 'function') throw new Error("A function needs to be provided when calling .generate");
				cb(query);
				return REQUEST;
			},

			then: function then(cb) {
				return MAKE_REQUEST().then(function (res) {
					logger.print();
					return cb(res, _normalize);
				});
			},
			normalize: function normalize(cb) {
				return MAKE_REQUEST().then(function (res) {
					var normalizedResponse = _normalize(res.data);
					logger.add("Normalized Response", normalizedResponse);
					logger.print();
					return cb(_extends({}, res, normalizedResponse));
				});
			}
		};

		return REQUEST;
	};
};