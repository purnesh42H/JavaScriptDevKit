'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.FETCH_API = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _public = require('./public');

var _types = require('../types');

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The fetch implementation that is used to make requests.
 *
 * It returns a promise containing a RequestResponse type object.
 * If the response from the api contains an 'errors' property,
 * a GraphQLError will be thrown. This behaviour can be disabled
 */
var FETCH_API = exports.FETCH_API = function FETCH_API(config) {
	var method = (config.method || "POST").toUpperCase();
	var server_response = void 0;

	return (0, _isomorphicFetch2.default)(config.endpoint, _extends({
		headers: _extends({
			'Accept': 'application/json',
			'Content-Type': 'application/json'
		}, config.headers),
		method: method
	}, method != "GET" && method != "HEAD" ? {
		body: JSON.stringify(config.body)
	} : {})).then(function (res) {
		/* convert the body to json but also store the raw server
   * response so as to not lose any information.
   * */
		server_response = res;
		return res.json();
	}).then(function (res) {
		/* If the GraphQL server responded with errors then throw
   * an error of type GraphQLError.
   * */
		if (res.errors && config.throwOnErrors) {
			if (config.throwOnErrors) throw new _public.GraphQLError("The GraphQL server responded with errors.", res.errors);
		}

		return _extends({
			server_response: server_response
		}, res);
	});
};