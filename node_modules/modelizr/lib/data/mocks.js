'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _random2 = require('lodash/random');

var _random3 = _interopRequireDefault(_random2);

var _mapKeys2 = require('lodash/mapKeys');

var _mapKeys3 = _interopRequireDefault(_mapKeys2);

var _times2 = require('lodash/times');

var _times3 = _interopRequireDefault(_times2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _mapValues2 = require('lodash/mapValues');

var _mapValues3 = _interopRequireDefault(_mapValues2);

var _sample2 = require('lodash/sample');

var _sample3 = _interopRequireDefault(_sample2);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _types = require('../types');

var _filters = require('../tools/filters');

var _dataGeneration = require('./dataGeneration');

var _uuid = require('../tools/uuid');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Given a Data Description and a collection of query models, recursively
 * generate data that matches the type-specified of the model.
 *
 * This function will return a promise as it is mocking a fetch request.
 */
exports.default = function (clientState, queryModels) {
	var mockConfig = clientState.config.mock;

	var generate = (0, _dataGeneration.generator)(clientState.config.faker);

	var mockModels = function mockModels(models) {
		var mockModel = function mockModel(model) {
			var currentModel = model;
			var modelData = clientState.models[model.modelName];
			var schemaAttribute = null;

			/* If the model being mocked is a Union, then it has no actual 'fields'
    * that we can mock. We need to keep track of its schemaAttribute and
    * then randomly select one of its Child Models. We override the
    * currently set ModelFunction with this chosen Model.
    * */
			if (modelData._unionDataType) {
				if (!model.children.length) throw new Error('No children were given to union ' + model.fieldName);
				schemaAttribute = modelData.schemaAttribute;
				currentModel = (0, _sample3.default)(model.children);
				modelData = clientState.models[currentModel.modelName];

				/* If the schemaAttribute of the union is a function, then look for
     * a schemaType on the chosen model.
     * */
				if (typeof schemaAttribute === 'function') schemaAttribute = modelData.schemaType;
			}
			var fieldsToMock = (0, _filters.stripRelationships)(modelData.fields);

			/* Map over the filtered set of fields and generate information
    * based on their data type. If the field is a nested set of fields,
    * pass that field back into our mock function.
    * */
			var mockFields = function mockFields(fields) {
				return (0, _mapValues3.default)(fields, function (field) {
					var generateOrMock = function generateOrMock(field) {
						if (field.type === Object) {
							return mockFields((0, _filters.stripRelationships)(field.properties || {}));
						}
						return generate(field);
					};

					if (Array.isArray(field.type)) {
						return (0, _map3.default)((0, _times3.default)(field.quantity || 10), function () {
							return generateOrMock(_extends({}, field, { type: field.type[0] }));
						});
					}

					return generateOrMock(field);
				});
			};

			var mockedFields = mockFields(fieldsToMock);

			/* If this model is querying child models, then they also need
    * to be mocked. We first check their relationship description
    * to figure out if they should be mocked as a collection or as
    * a single entity.
    * */
			var keyedFunctions = (0, _mapKeys3.default)(currentModel.children, function (model) {
				return model.fieldName;
			});
			var mockedChildren = (0, _mapValues3.default)(keyedFunctions, function (model, fieldName) {
				if (modelData.fields[fieldName]) {
					var _modelData$fields$fie = modelData.fields[fieldName],
					    type = _modelData$fields$fie.type,
					    quantity = _modelData$fields$fie.quantity;

					if (Array.isArray(type)) {
						return (0, _map3.default)((0, _times3.default)(quantity || 10), function () {
							return mockModel(model);
						});
					}
				}

				return mockModel(model);
			});

			mockedFields = _extends({}, mockedFields, mockedChildren);

			/* Replace the generated primaryKey data with a V4 UUID string and, if
    * the model is a union type, set its schemaAttribute accordingly.
    * */
			if (modelData && mockedFields[modelData.primaryKey]) {
				var pk = (0, _uuid.v4)();
				if (modelData.fields[modelData.primaryKey].type === Number) {
					pk = (0, _random3.default)(10000, 99999);
				}
				mockedFields[modelData.primaryKey] = pk;
			}
			if (schemaAttribute) mockedFields[schemaAttribute] = currentModel.modelName;

			return mockedFields;
		};

		/* We look at mock config to determine if we should generate an array
   * of data or single entities
   * */
		var keyedFunctions = (0, _mapKeys3.default)(models, function (model) {
			return model.fieldName;
		});
		return (0, _mapValues3.default)(keyedFunctions, function (model, field) {
			if ((typeof mockConfig === 'undefined' ? 'undefined' : _typeof(mockConfig)) === 'object') {
				if (mockConfig[field] && mockConfig[field] === Array) return (0, _map3.default)((0, _times3.default)(10), function () {
					return mockModel(model);
				});
			}
			return mockModel(model);
		});
	};

	return new Promise(function (resolve) {
		return resolve({
			server_response: {},
			data: mockModels(queryModels),
			errors: null
		});
	});
};